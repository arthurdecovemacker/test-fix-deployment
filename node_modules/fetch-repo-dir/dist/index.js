"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}var r=t(require("fs-extra")),e=t(require("tmp")),n=t(require("path")),o=t(require("https")),a=t(require("tar"));const i=new Set(["github","gitlab","bitbucket"]);e.setGracefulCleanup(),module.exports=async function(t,c={}){Array.isArray(t)||(t=[t]),c=Object.assign({replace:!1,onDownloadStart:()=>{},onDownloadEnd:()=>{},onUnpackStart:()=>{},onUnpackEnd:()=>{},onCopyStart:()=>{},onCopyEnd:()=>{}},c);const s=e.dirSync({unsafeCleanup:!0}),u=s.name,p=async(t,e)=>{const s=function(t){const r=/^(?:https:\/\/([^\/]+)\/)?([^\/\s]+)\/([^\/\s#]+)(\/[^\s#]+)?(?:#(.+))?/.exec(t);if(!r)throw new Error("could not parse "+t);const e=(r[1]||"github").replace(/\.(com|org)$/,"");if(!i.has(e))throw new Error("Supported GitHub, GitLab and BitBucket only");const n=r[2],o=r[3],a=(r[4]||"").replace(/^\//,""),c=r[5]||"master",s=`https://${e}.${"bitbucket"===e?"org":"com"}/${n}/${o}`;return{site:e,user:n,name:o,ref:c,path:a,url:s,gz:"gitlab"===e?`${s}/repository/archive.tar.gz?ref=${c}`:"bitbucket"===e?`${s}/get/${c}.tar.gz`:`${s}/archive/${c}.tar.gz`}}(t),p=`${s.site}_${s.user}_${s.name}_${s.ref}`.replace(/[^a-z0-9_]/gi,"_"),d=n.join(u,p+".tar.gz"),l=n.join(u,p),f=n.join(l,s.path.split("/").join(n.sep)),h=n.resolve(e);if(!r.existsSync(l)){r.mkdirSync(l);try{c.onDownloadStart(s.gz,d),await function t(e,n){return new Promise((a,i)=>{o.get(e,e=>{const o=e.statusCode;o>=400?i({code:o,message:e.statusMessage}):o>=300?t(e.headers.location,n).then(a,i):e.pipe(r.createWriteStream(n)).on("finish",()=>a()).on("error",i)}).on("error",i)})}(s.gz,d),c.onDownloadEnd(s.gz,d)}catch(t){throw new Error(`unsuccessful download of ${s.gz};${t}`)}}try{c.onUnpackStart(d,l),await async function(t,r){return a.extract({file:t,strip:1,C:r})}(d,l),c.onUnpackEnd(d,l)}catch(t){throw new Error("can't unpack "+d)}if(!c.replace&&r.existsSync(h)&&r.readdirSync(h).length>0)throw new Error("destination directory is not empty");r.mkdirpSync(h),c.onCopyStart(f,h),r.copySync(f,h),c.onCopyEnd(f,h)};for(let r=0;r<t.length;r++){const e=t[r];if(!e.src||!e.dir)throw new Error("invalid source and/or distonation provided");await p(e.src,e.dir)}s.removeCallback()};
